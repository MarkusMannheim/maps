<!DOCTYPE html>
<html>
  <head>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-155991615-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag("js", new Date());
      gtag("config", "UA-155991615-1");
    </script>

    <!-- metaphysics -->
    <meta charset="utf-8">
    <title>Canberra's retirement exodus</title>
    <meta name="author" content="Markus Mannheim">
    <meta name="keywords" content="act, canberra, population, ages, data, retirement, migration, internal">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- scripts -->
    <script src="./resources/d3.v7.min.js"></script>
    <script src="./resources/topojson.v3.min.js"></script>
    <link href="./resources/flightStyle.css" rel="stylesheet">
    <link href="./resources/abcLogo64.png" rel="icon">
  </head>

  <body>
    <div id="container">
      <svg id="map">
        <g id="mapGroup"></g>
      </svg>
      <div id="footer">
        Top 50 suburbs/towns for people aged 50â€“69 who lived in the ACT in 2016 then moved.
        Suburbs within 100km of Civic excluded.
        Circle size indicates number of people.
      </div>
      <div id="controls">

      </div>
      <div id="tip"></div>
    </div>

    <script>
      // elements
      container = d3.select("#container");
      map = d3.select("#map");
      mapGroup = d3.select("#mapGroup");
      footer = d3.select("#footer");
      controls = d3.select("#controls");
      tip = d3.select("#tip");

      // load data
      Promise.all([
        d3.json("./data/flightMap.topojson"),
        d3.json("./data/flightDestinations.geojson"),
        d3.svg("./resources/home.svg"),
        d3.svg("./resources/plus.svg"),
        d3.svg("./resources/minus.svg")
      ])
        .then(function(data) {
          // format data
          mapData = topojson
            .feature(data[0], data[0].objects.flightMap);
          destinationData = {
            type: "FeatureCollection",
            features: data[1]
              .features
              .map(d => {
                if (d.properties.area.includes("(")) {
                  d.properties.area = d.properties.area.slice(0, d.properties.area.indexOf("(") - 1);
                }                
                return d;
              })
          };
          iconHome = data[2];
          iconPlus = data[3];
          iconMinus = data[4];          

          // await fonts
          document.fonts.onloadingdone = fontsReady();
        });

      function fontsReady() {
        // await user (scroll to map)
        loadTarget = document.querySelector("#map");

        // set up frame activation
        observer = new IntersectionObserver(loadFrame, {threshold: 0.5});
        observer.observe(loadTarget);
      }

      function loadFrame(interactionObjects) {
        interactionObjects.map(function(object) {
          if (object.isIntersecting) drawMap();
        });
      }

      function drawMap() {
        observer.unobserve(loadTarget);

        container.transition()
          .style("opacity", 1);
          
        land = mapGroup
          .selectAll(".land")
            .data(mapData.features)
          .enter().append("path")
            .attr("class", d => {
              return d.properties["class"] == "map" ? "land" : "land ACT";
            });

        destinations = mapGroup
          .selectAll(".destination")
            .data(destinationData.features)
          .enter().append("path")
            .classed("destination", true);

        icons = [
          [iconPlus, "plus"],
          [iconHome, "home"],
          [iconMinus, "minus"]
        ];

        icons.forEach(d => {
          let icon = d3.select(controls.node()
            .appendChild(d[0].querySelector("svg")));
          icon.classed("icon", true)
            .attr("id", d[1])
            .on("mouseover", iconOn)
            .on("mouseout", iconOff)
            .on("click", control)
        });

        centroid = d3.geoCentroid(mapData);
        projection = d3.geoOrthographic()
          .rotate([-centroid[0], -centroid[1]]);
        path = d3.geoPath()
          .projection(projection);
        circleScale = d3.scaleLinear()
          .domain(d3.extent(destinationData.features.map(d => Math.sqrt(d.properties.value / Math.PI))));
        window.addEventListener("resize", resize);
        initialZoom = true;
        zooming = false;
        zoomLength = 4000;
        regularZoomLength = 250;
        centroid = d3.geoCentroid(mapData);
        projection.rotate([-centroid[0], -centroid[1]]);
        transform = d3.zoomTransform(mapGroup.node());
        resize();        
        setUpZoom();
      }

      function iconOn() {
        this.classList.add("hover");
      }

      function iconOff() {
        this.classList.remove("hover");
      }

      function control() {
        d3.timeout(() => this.classList.remove("hover"), 250);
        controlAction = this.id;
        transform = d3.zoomTransform(mapGroup.node());
        if (controlAction !== "home") {
          let startScale = transform.k;
          let newScale = controlAction == "plus" ?
            Math.min(zoom.scaleExtent()[1], startScale * 1.3) :
            Math.max(1, transform.k / 1.3);
          transform.k = newScale;
          let distance = [
            width / 2 - transform.x,
            height / 2 - transform.y
          ];
          let newDistance = [
            distance[0] * newScale / startScale,
            distance[1] * newScale / startScale
          ];
          transform.x = width / 2 - newDistance[0];
          transform.y = height / 2 - newDistance[1];
        } else {
          transform.x = 0;
          transform.y = 0;
          transform.k = 1;
        }
        mapGroup.transition()
          .attr("transform", transform);
        land.transition()
          .style("stroke-width", 1 / transform.k);
        destinations.transition()
          .attr("d", d => path.pointRadius(circleScale(Math.sqrt(d.properties.value / Math.PI) / transform.k))(d));
        cellData = destinationData
          .features
          .map(d => {
            let coords = projection(d.geometry.coordinates);
            return [transform.x + coords[0] * transform.k, transform.y + coords[1] * transform.k, d.properties.area, d.properties.value];
          })
          .filter(d => d[0] >= 0 && d[0] <= width && d[1] >= 0 && d[1] <= height);
        delaunay = d3.Delaunay
          .from(cellData);
        voronoi = delaunay
          .voronoi([0, 0, width, height]);
        cells = map
          .selectAll(".cell")
            .data(cellData);
        cells.exit()
          .remove();
        cells.enter()
          .append("path")
            .classed("cell", true)
            .on("mouseover", cellOn)
            .on("mouseout", cellOff)
            .attr("d", (d, i) => voronoi.renderCell(i))
            .style("pointer-events", "auto");
        cells.attr("d", (d, i) => voronoi.renderCell(i));
      }

      function setUpZoom() {
        d3.timeout(() => {
          initialZoom = false;
          zooming = true;
          centroid = d3.geoCentroid(destinationData);
          projection.rotate([-centroid[0], -centroid[1]]);
          resize();
          d3.timeout(activeControls, zoomLength);
        }, 1500);
      }

      function activeControls() {
        zooming = false;
        cells.style("pointer-events", "auto");
        controls.style("pointer-events", "auto")
          .transition()
            .style("opacity", 1);

        zoom = d3.zoom()
          .scaleExtent([1, 15])
          .translateExtent([[0, 0], [width, height]])
          .on("zoom", zoomed);
        map.call(zoom);
       
        function zoomed(event) {
          cellOff();  
          transform = event.transform;
          mapGroup.attr("transform", transform);
          land.style("stroke-width", 1 / transform.k);
          destinations.attr("d", d => path.pointRadius(circleScale(Math.sqrt(d.properties.value / Math.PI) / transform.k))(d));
          cellData = destinationData
            .features
            .map(d => {
              let coords = projection(d.geometry.coordinates);
              return [transform.x + coords[0] * transform.k, transform.y + coords[1] * transform.k, d.properties.area, d.properties.value];
            })
            .filter(d => d[0] >= 0 && d[0] <= width && d[1] >= 0 && d[1] <= height);
          delaunay = d3.Delaunay
            .from(cellData);
          voronoi = delaunay
            .voronoi([0, 0, width, height]);
          cells = map
            .selectAll(".cell")
              .data(cellData);
          cells.exit()
            .remove();
          cells.enter()
            .append("path")
              .classed("cell", true)
              .on("mouseover", cellOn)
              .on("mouseout", cellOff)
              .attr("d", (d, i) => voronoi.renderCell(i))
              .style("pointer-events", "auto");
          cells.attr("d", (d, i) => voronoi.renderCell(i));
        }
      }

      function resize() {
        dimensions = document.getElementById("map").getBoundingClientRect();
        width = dimensions.width;
        height = width;

        margin = {
          top: 25,
          right: 25,
          bottom: 25,
          left: 25
        };

        // set chart height
        map.style("height", height + "px");
        iframeHeight = document.getElementById("container").getBoundingClientRect().height;
        
        // send dimensions to host window
        if (initialZoom) {
          window.parent.postMessage({
            sentinel: "amp",
            type: "embed-size",
            height: iframeHeight
          }, "*");
        }

        // redraw map
        baseCircle = (width > 500 ? 3.5 : 2);
        if (initialZoom) {
          projection.fitExtent([[margin.left, margin.top], [width - margin.left, height - margin.bottom]], mapData);
        } else if (zooming) {
          minScale = projection.scale();
          projection.fitExtent([[margin.left, margin.top], [width - margin.left, height - margin.bottom]], destinationData);
          baseCircle = baseCircle * projection.scale() / minScale;
        } else {
          baseCircle = baseCircle * projection.scale() / minScale;
        }
        circleScale.range([baseCircle, baseCircle * circleScale.domain()[1] / circleScale.domain()[0]]);

        land.transition()
          .duration(zooming ? zoomLength : regularZoomLength)
          .attr("d", path);
        destinations.transition()
          .duration(zooming ? zoomLength : regularZoomLength)
            .attr("d", d => path.pointRadius(circleScale(Math.sqrt(d.properties.value / Math.PI)))(d));

        cellData = destinationData
          .features
          .map(d => {
            let coords = projection(d.geometry.coordinates);
            return [transform.x + coords[0] * transform.k, transform.y + coords[1] * transform.k, d.properties.area, d.properties.value];
          })
          .filter(d => d[0] >= 0 && d[0] <= width && d[1] >= 0 && d[1] <= height);
        delaunay = d3.Delaunay
          .from(cellData);
        voronoi = delaunay
          .voronoi([0, 0, width, height]);
        cells = map
          .selectAll(".cell")
            .data(cellData);
        cells.exit()
          .remove();
        cells.enter()
          .append("path")
            .classed("cell", true)
            .on("mouseover", cellOn)
            .on("mouseout", cellOff)
            .attr("d", (d, i) => voronoi.renderCell(i));
        cells.attr("d", (d, i) => voronoi.renderCell(i));
      }

      function cellOn(event, d) {
        let point = [d[0], d[1]];
        tip.style("opacity", 0)
          .style("top", "0px")
          .style("left", "0px")
          .html("<p class='label'>" + d[2] + "</span></p>" + "<p>" + d[3] + " <span>people</span></p>");
        let tipWidth = tip.node().getBoundingClientRect().width;
        let tipHeight = tip.node().getBoundingClientRect().height;
        tip.style("top", () => {
          let top = point[1] - tipHeight / 2 < margin.top ? margin.top :
            point[1] - tipHeight / 2 > height - margin.bottom ? height - margin.bottom :
            point[1] - tipHeight / 2;
          return top + "px";
        }).style("left", () => {
          let left = point[0] - tipWidth / 2 < margin.left ? margin.left :
            point[0] - tipWidth / 2 > width - margin.right ? width - margin.right :
            point[0] - tipWidth / 2;
          return left + "px";
        }).style("opacity", 1);
        destinations.filter(e => e.properties.area == d[2])
          .classed("selected", true);
      }

      function cellOff() {
        tip.style("opacity", 0);
        destinations.classed("selected", false);
      }
    </script>
  </body>
</html>
